% Authors:
%		Gabriel Ferreira Silva (*)
% 		Mauricio Ayala-Rincón (*)
% 		Daniele Nantes Sobrinho (*)
% 		Maribel Fernandez (**)
%		(*) - University of Brasília			(**) - King's College London
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

unification_alg: THEORY
BEGIN
	IMPORTING rename_input, list_theory[sub]


IMPORTING map_theory[nice_input, [fresh_context, sub]]

Delta, Nabla, Nabla_, G, Gamma, Gamma1: VAR fresh_context
pi: VAR perm

a: VAR atom
X: VAR variable
t, s: VAR term
sigma, sigma1, delta, gamma, gamma_: VAR sub
vars2avoid, fixed_vars, V, PV: VAR finite_set[variable]

up, unif_pair: VAR unif_pair
unif_prb, P, P1: VAR unif_prb
unif_prb1: VAR unif_prb
id: VAR sub
input, input_: VAR nice_input
rho: VAR renaming

% the AC-unification algorithm. In our paper we refer to it as ACUnif.
unify(input): RECURSIVE list[[fresh_context, sub]] =
  LET (G, P, sigma, V, PV) = input IN 
  IF null?(P) THEN cons((G, sigma), null)
  ELSE LET
     (up, P1) = choose_eq(P), 
     (t, s) = up IN 

     % TO DO: this is omitted since the variable s is always protected in a matching problem
     %IF var?(s) AND (NOT member(V(s), vars(t))) AND (NOT member(V(s), PV)) THEN LET
        %sigma1 = cons((V(s), ext(reverse(p(s)))(t)), null),
	%(G1, bool1) = fresh_subs?(sigma, G), 
	%new_G = append(G1, G), 
	%new_sigma = append(sigma1, sigma), 
	%new_P = apply_sub(sigma1, P1)
	%IF bool1 THEN unify(new_G, new_P, new_sigma, V, PV)
	%ELSE null 
	%ENDIF

     CASES t OF
        at(a):
	  IF s = at(a) THEN unify(G, P1, sigma, V, PV)
	  ELSE null
	  ENDIF,

	*(pi, X):
	  IF (NOT member(X, vars(s))) AND (NOT member(X, PV))  THEN LET
	    sigma1 = cons((X, ext(reverse(pi))(s)), null),
	    (G1, bool1) = fresh_subs?(sigma1, G), 
	    new_G = append(G1, G), 
	    new_sigma = append(sigma1, sigma), 
	    new_P = apply_sub(sigma1, P1) IN 
	    IF bool1 THEN unify(new_G, new_P, new_sigma, V, PV)
	    ELSE null 
	    ENDIF

	  ELSIF var?(s) AND X = V(s) THEN LET
	    new_G = append(fc(DS(pi, p(s)), X), G) IN
	    unify(new_G, P1, sigma, V, PV)
	  ELSE null
	  ENDIF,

	unit:
	  IF s = unit THEN unify(G, P1, sigma, V, PV)  
	  ELSE null 
	  ENDIF,

	app(f, arg):
	  IF NOT app?(s) OR f /= f_sym(s) OR NOT decompose(arg, arg(s))`2 THEN null 
	  ELSE LET dec_P = decompose(arg, arg(s))`1,
	       	   new_P = append(dec_P, P1) IN
		   unify(G, new_P, sigma, V, PV)
	  ENDIF,

        abs(a, bd):
	  IF NOT abs?(s) OR NOT decompose(bd, body(s))`2 THEN null 
	  ELSIF a = abstr(s) THEN LET
	        dec_P = decompose(bd, body(s))`1, 
	        new_P = append(dec_P, P1) IN 
	  	unify(G, new_P, sigma, V, PV)	
	  ELSE LET
	       (G1, bool1) = fresh?(a, body(s)),
	       new_G = append(G1, G), 
	       pi = cons((a, abstr(s)), null), 
	       dec_P = decompose(bd, ext(pi)(body(s)))`1, 
	       new_P = append(dec_P, P1) IN 
	       IF bool1 THEN unify(new_G, new_P, sigma, V, PV)
	       ElSE null
	       ENDIF
	  ENDIF, 

	ac_app(f, ac_arg):
	  IF NOT ac_app?(s) OR f /= ac_sym(s) THEN null
	  ELSE LET
	     input_lst = apply_ac(G, cons((t, s), P1), sigma, V, PV), 
	     lst_results = map(unify)(input_lst) IN 
	     flatten(lst_results) 
	  ENDIF
        ENDCASES
    ENDIF
MEASURE lex3(card(vars(input`2)), max_size(input`2), num_max_size(input`2))

%%%%%%%%%%%% LEMMAS
unify_sound_inst: LEMMA 
   LET (G, P, sigma, V, PV) = input IN 
   (NOT null?(P) AND
   LET (up, P1) = choose_eq(P), (t, s) = up IN 
   var?(t) AND NOT member(V(t), vars(s)) AND 
   LET sigma1 = cons((V(t), ext(reverse(p(t)))(s)), null),
       (G1, bool1) = fresh_subs?(sigma1, G), 
       new_G = append(G1, G), 
       new_sigma = append(sigma1, sigma), 
       new_P = apply_sub(sigma1, P1) IN 
   is_sol?(Delta, delta)(new_G, new_P, new_sigma, PV)) IMPLIES
   is_sol?(Delta, delta)(G, P, sigma, PV)

unify_sound_abs: LEMMA
   LET (G, P, sigma, V, PV) = input IN 
   (NOT null?(P) AND 
   LET (up, P1) = choose_eq(P), (t, s) = up IN 
   abs?(t) AND abs?(s) AND decompose(body(t), body(s))`2 AND
   abstr(t) /= abstr(s) AND 
   LET (G1, bool1) = fresh?(abstr(t), body(s)),
       new_G = append(G1, G), 
       pi = cons((abstr(t), abstr(s)), null), 
       dec_P = decompose(body(t), ext(pi)(body(s)))`1, 
       new_P = append(dec_P, P1) IN 
   bool1 AND is_sol?(Delta, delta)(new_G, new_P, sigma, PV)) IMPLIES
   is_sol?(Delta, delta)(G, P, sigma, PV)

unify_sound: LEMMA 
   LET (Gamma, P, sigma, V, PV) = input IN 
   is_sol?(Delta, delta)(Gamma1, null, sigma1, PV) AND 
   member((Gamma1, sigma1), unify(input)) IMPLIES
   is_sol?(Delta, delta)(Gamma, P, sigma, PV)

unify_sound_cor: LEMMA 
   is_sol?(Delta, delta)(Gamma, null, sigma, vars(s)) AND well_formed?((t, s)) AND
   member((Gamma, sigma), unify(null, cons((t, s), null), null, vars(t, s), vars(s))) IMPLIES 
   is_sol?(Delta, delta)(null, cons((t, s), null), null, vars(s)) 

unify_completeness_inst: LEMMA 
   LET (G, P, sigma, V, PV) = input,  
       (up, P1) = choose_eq(P), (t, s) = up IN 
   is_sol?(Delta, delta)(G, P, sigma, PV) AND
   NOT null?(P) AND var?(t) AND NOT member(V(t), vars(s)) IMPLIES 
   (LET sigma1 = cons((V(t), ext(reverse(p(t)))(s)), null),
       (G1, bool1) = fresh_subs?(sigma1, G), 
       new_G = append(G1, G), 
       new_sigma = append(sigma1, sigma), 
       new_P = apply_sub(sigma1, P1) IN 
   bool1 IMPLIES is_sol?(Delta, delta)(new_G, new_P, new_sigma, PV))

unify_completeness_inst2: LEMMA 
   LET (G, P, sigma, V, PV) = input,  
       (up, P1) = choose_eq(P), (t, s) = up IN 
   is_sol?(Delta, delta)(G, P, sigma, PV) AND
   NOT null?(P) AND var?(t) AND NOT member(V(t), vars(s)) IMPLIES 
   (LET sigma1 = cons((V(t), ext(reverse(p(t)))(s)), null),
       (G1, bool1) = fresh_subs?(sigma1, G), 
       new_G = append(G1, G), 
       new_sigma = append(sigma1, sigma), 
       new_P = apply_sub(sigma1, P1) IN bool1)

unify_completeness_inst3: LEMMA 
   LET (G, P, sigma, V, PV) = input,  
       (up, P1) = choose_eq(P), (t, s) = up IN 
   is_sol?(Delta, delta)(G, P, sigma, PV) AND
   NOT null?(P) AND var?(t) AND var?(s) AND V(t) = V(s) IMPLIES 
   (LET new_G = append(fc(DS(p(t), p(s)), V(t)), G) IN
        is_sol?(Delta, delta)(new_G, P1, sigma, PV))

unify_completeness_abs: LEMMA 
   LET (G, P, sigma, V, PV) = input,  
       (up, P1) = choose_eq(P), (t, s) = up IN 
   is_sol?(Delta, delta)(G, P, sigma, PV) AND
   NOT null?(P) AND abs?(t) AND abs?(s) AND abstr(t) /= abstr(s) AND
   decompose(body(t), body(s))`2 IMPLIES 
   (LET (G1, bool1) = fresh?(abstr(t), body(s)),
	new_G = append(G1, G), 
	pi = cons((abstr(t), abstr(s)), null), 
	dec_P = decompose(body(t), ext(pi)(body(s)))`1, 
	new_P = append(dec_P, P1) IN 
	bool1 AND is_sol?(Delta, delta)(new_G, new_P, sigma, PV))

unify_completeness: CONJECTURE 
   LET (Gamma, P, sigma, V, PV) = input IN 
   is_sol?(Delta, delta)(Gamma, P, sigma, PV) AND contained?(delta, V) IMPLIES 
   EXISTS Gamma1, sigma1: 
      member((Gamma1, sigma1), unify(input)) AND
      solves?(Delta, delta)(Gamma1, null, sigma1, PV)


% some properties of the substitutions computed, needed for the lemmas of soundness and completeness
unify_subs: CONJECTURE 
   LET (G, P, sigma, V, PV) = input IN 
   member((Nabla, delta), unify(G, P, sigma, V, PV)) IMPLIES
   EXISTS sigma1:
      delta = append(sigma1, sigma)

unify_well_formed: CONJECTURE  
   LET (G, P, sigma, V, PV) = input IN 
   member((Nabla, delta), unify(G, P, sigma, V, PV)) IMPLIES
   well_formed?(delta) 

renamed_inputs_unify_alg: CONJECTURE  
   renamed_inputs?(input, input_, fixed_vars) AND member((Nabla_, gamma_), unify(input_)) IMPLIES
   EXISTS rho, Nabla, gamma: 
       member((Nabla, gamma), unify(input)) AND equal_syn?(gamma_, append(rho, gamma), fixed_vars)

% correctness of instantiation
% TO DO: this will need to be adapted
unify_alg_correct_sub: CONJECTURE  
    LET sigma1 = cons((X, t), null), new_sigma = append(sigma1, sigma),
        new_P = apply_sub(sigma1, P) IN
    (NOT member(X, vars(t))) AND member(pi * X, P) AND member(t, unif_prb)
    AND nice_input?(G, P, sigma, V, PV) AND subset?(P, P) AND 
    unifies?(G, delta, new_P) AND member((Nabla, delta), unify(G, P, sigma, V, PV))
    IMPLIES
    unifies?(G, delta, (pi * X, t)) AND unifies?(G, delta, P)
  
% Main theorem to prove the corollary of Soundness. Here, "input" is of type nice input (see line 14, 26). 
unify_alg_correct: CONJECTURE  
    LET (G, P, sigma, V, PV) = input IN 
    member((Nabla, delta), unify(G, P, sigma, V, PV))
    IMPLIES unifies?(Nabla, delta, P)

% theorem of correctness, corollary from the previous lemma
unify_alg_correct_cor: CONJECTURE
    well_formed?((t, s)) AND member((Nabla, delta), unify(null, cons((t, s), null), null, vars(t, s), vars(s))) 
    IMPLIES unifies?(Nabla, delta, cons((t, s), null))

% used in the proof of completeness for the instantiation case
unify_alg_complete_sub: CONJECTURE    
    LET sigma1 = cons((X, t), null), new_sigma = append(sigma1, sigma),
        new_P = apply_sub(sigma1, P) IN
    (NOT member(X, vars(t))) AND member(pi * X, unif_pair) AND member(t, unif_pair)
    AND member(unif_pair, P) AND nice_input?(G, P, sigma, V, PV) AND
    subset?(P1, P) AND 
    unifies?(Nabla, delta, P) AND more_general?(G)(sigma, delta) IMPLIES
    more_general?(G)(new_sigma, delta) AND unifies?(Nabla, delta, apply_sub(sigma1, unif_prb1))

% main theorem to prove the corollary of completeness. As was the case for soudness, here input is of type "nice_input". 
unify_alg_complete: CONJECTURE 
    LET (G, P, sigma, V, PV) = input IN 
    unifies?(Nabla, delta, P) AND more_general?(G)(sigma, delta) AND contained?(delta, V)
    AND well_formed?(delta) IMPLIES 
    EXISTS gamma:
       member((Nabla, gamma), unify(G, P, sigma, V, PV)) AND 
       more_general?(G)(gamma, delta, V)

% theorem of completeness for the algorithm 
unify_alg_complete_cor: CONJECTURE 
    well_formed?((t, s)) AND unifies?(Nabla, delta, (t, s))  
    AND contained?(delta, V) AND subset?(vars(t, s), V) AND well_formed?(delta)
    IMPLIES 
    EXISTS Nabla, gamma: 
       member((Nabla, gamma), unify(null, cons((t, s), null), null, V, PV)) AND
       more_general?(G)(gamma, delta, V)

% completeness after we remove the hypthesis
unify_alg_complete_cor2: CONJECTURE   
    well_formed?((t, s)) AND unifies?(G, delta, (t, s)) AND well_formed?(delta)
    IMPLIES
    EXISTS gamma, Nabla:
       member((Nabla, gamma), unify(G, cons((t, s), null), null, vars(t, s), PV)) AND
       more_general?(G)(gamma, delta, vars(t, s))
    
END unification_alg 
